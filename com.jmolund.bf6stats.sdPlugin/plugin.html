<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>BF6 Stats Plugin</title>
</head>
<body>
<script>
const API_BASE = 'https://api.gametools.network/bf6/stats/';
const STAT_MODES = ['logo', 'kd', 'kills', 'wins'];
const REFRESH_INTERVAL = 5 * 60 * 1000; // 5 minutes
const CYCLE_INTERVAL = 5 * 1000; // 5 seconds per stat

let websocket = null;
let pluginUUID = null;
const contexts = new Map();
const statsCache = new Map();

function connectElgatoStreamDeckSocket(inPort, inPluginUUID, inRegisterEvent, inInfo) {
  pluginUUID = inPluginUUID;

  websocket = new WebSocket('ws://127.0.0.1:' + inPort);

  websocket.onopen = function() {
    websocket.send(JSON.stringify({
      event: inRegisterEvent,
      uuid: inPluginUUID
    }));
  };

  websocket.onmessage = function(evt) {
    const message = JSON.parse(evt.data);
    handleMessage(message);
  };

  websocket.onerror = function(error) {
    console.error('WebSocket error:', error);
  };
}

function handleMessage(message) {
  const event = message.event;
  const context = message.context;
  const payload = message.payload || {};

  switch(event) {
    case 'willAppear':
      onWillAppear(context, payload);
      break;
    case 'willDisappear':
      onWillDisappear(context);
      break;
    case 'keyUp':
      onKeyUp(context, payload);
      break;
    case 'didReceiveSettings':
      onDidReceiveSettings(context, payload);
      break;
  }
}

function onWillAppear(context, payload) {
  const settings = payload.settings || {};
  contexts.set(context, {
    settings: settings,
    currentStatIndex: 0,
    refreshInterval: null,
    cycleInterval: null
  });

  startRefreshInterval(context);
  startCycleInterval(context);
  fetchAndDisplayStats(context);
}

function onWillDisappear(context) {
  const contextData = contexts.get(context);
  if (contextData) {
    if (contextData.refreshInterval) {
      clearInterval(contextData.refreshInterval);
    }
    if (contextData.cycleInterval) {
      clearInterval(contextData.cycleInterval);
    }
  }
  contexts.delete(context);
}

function onKeyUp(context, payload) {
  const contextData = contexts.get(context);
  if (!contextData) return;

  // Cycle to next stat
  contextData.currentStatIndex = (contextData.currentStatIndex + 1) % STAT_MODES.length;
  displayCurrentStat(context);
}

function onDidReceiveSettings(context, payload) {
  const contextData = contexts.get(context);
  if (contextData) {
    contextData.settings = payload.settings || {};
    fetchAndDisplayStats(context);
  }
}

function startRefreshInterval(context) {
  const contextData = contexts.get(context);
  if (!contextData) return;

  if (contextData.refreshInterval) {
    clearInterval(contextData.refreshInterval);
  }

  contextData.refreshInterval = setInterval(function() {
    fetchAndDisplayStats(context);
  }, REFRESH_INTERVAL);
}

function startCycleInterval(context) {
  const contextData = contexts.get(context);
  if (!contextData) return;

  if (contextData.cycleInterval) {
    clearInterval(contextData.cycleInterval);
  }

  contextData.cycleInterval = setInterval(function() {
    // Only cycle if we have stats loaded
    if (statsCache.has(context)) {
      contextData.currentStatIndex = (contextData.currentStatIndex + 1) % STAT_MODES.length;
      displayCurrentStat(context);
    }
  }, CYCLE_INTERVAL);
}

function fetchAndDisplayStats(context) {
  const contextData = contexts.get(context);
  if (!contextData) return;

  const settings = contextData.settings;
  const playerName = settings.playerName;
  const platform = settings.platform || 'pc';

  if (!playerName) {
    setImage(context, 'images/logo');
    setTitle(context, '');
    return;
  }

  const url = API_BASE + '?name=' + encodeURIComponent(playerName) + '&platform=' + platform + '&format_values=true';

  fetch(url)
    .then(function(response) {
      if (!response.ok) {
        throw new Error('HTTP ' + response.status);
      }
      return response.json();
    })
    .then(function(data) {
      if (data.errors || !data.userName) {
        setTitle(context, 'Not\nFound');
        return;
      }

      // Get stats from API response
      const kills = data.kills || 0;
      const deaths = data.deaths || 0;
      const wins = data.wins || 0;
      const loses = data.loses || 0;
      const kd = data.killDeath ? data.killDeath.toFixed(2) : '0.00';
      const winPercent = data.winPercent || '0.0%';

      statsCache.set(context, {
        kills: kills,
        deaths: deaths,
        kd: kd,
        wins: wins,
        losses: loses,
        winRate: winPercent.replace('%', ''),
        playerName: data.userName
      });

      displayCurrentStat(context);
    })
    .catch(function(error) {
      console.error('BF6 Stats fetch error:', error);
      setTitle(context, 'API\nError');
    });
}

function displayCurrentStat(context) {
  const contextData = contexts.get(context);
  const stats = statsCache.get(context);

  if (!contextData || !stats) return;

  const mode = STAT_MODES[contextData.currentStatIndex];
  let title = '';

  switch(mode) {
    case 'logo':
      setImage(context, 'images/logo');
      setTitle(context, '');
      return;
    case 'kd':
      title = 'K/D\n' + stats.kd;
      break;
    case 'kills':
      title = 'Kills\n' + formatNumber(stats.kills);
      break;
    case 'wins':
      title = 'Wins\n' + stats.winRate + '%';
      break;
  }

  clearImage(context);
  setTitle(context, title);
}

function formatNumber(num) {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + 'M';
  } else if (num >= 1000) {
    return (num / 1000).toFixed(1) + 'K';
  }
  return num.toString();
}

function setTitle(context, title) {
  if (websocket && websocket.readyState === WebSocket.OPEN) {
    websocket.send(JSON.stringify({
      event: 'setTitle',
      context: context,
      payload: {
        title: title,
        target: 0
      }
    }));
  }
}

function setImage(context, imagePath) {
  if (websocket && websocket.readyState === WebSocket.OPEN) {
    websocket.send(JSON.stringify({
      event: 'setImage',
      context: context,
      payload: {
        image: imagePath,
        target: 0
      }
    }));
  }
}

function clearImage(context) {
  if (websocket && websocket.readyState === WebSocket.OPEN) {
    websocket.send(JSON.stringify({
      event: 'setImage',
      context: context,
      payload: {
        image: null,
        target: 0
      }
    }));
  }
}
</script>
</body>
</html>
