<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>BF6 Stats Plugin</title>
</head>
<body>
<script>
const API_BASE = 'https://api.gametools.network/bf6/stats/';
const ALL_STAT_MODES = ['logo', 'kd', 'kills', 'wins', 'headshots', 'heals', 'repairs', 'revives', 'playtime', 'assists', 'matches'];
const REFRESH_INTERVAL = 5 * 60 * 1000; // 5 minutes
const CYCLE_INTERVAL = 5 * 1000; // 5 seconds per stat

let websocket = null;
let pluginUUID = null;
const contexts = new Map();
const statsCache = new Map();

function getEnabledModes(settings) {
  const modes = [];
  if (settings.showLogo !== false) modes.push('logo');
  if (settings.showKd !== false) modes.push('kd');
  if (settings.showKills !== false) modes.push('kills');
  if (settings.showWins !== false) modes.push('wins');
  if (settings.showHeadshots !== false) modes.push('headshots');
  if (settings.showHeals !== false) modes.push('heals');
  if (settings.showRepairs !== false) modes.push('repairs');
  if (settings.showRevives !== false) modes.push('revives');
  if (settings.showPlaytime !== false) modes.push('playtime');
  if (settings.showAssists !== false) modes.push('assists');
  if (settings.showMatches !== false) modes.push('matches');
  return modes.length > 0 ? modes : ['kd']; // Default to kd if nothing selected
}

function connectElgatoStreamDeckSocket(inPort, inPluginUUID, inRegisterEvent, inInfo) {
  pluginUUID = inPluginUUID;

  websocket = new WebSocket('ws://127.0.0.1:' + inPort);

  websocket.onopen = function() {
    websocket.send(JSON.stringify({
      event: inRegisterEvent,
      uuid: inPluginUUID
    }));
  };

  websocket.onmessage = function(evt) {
    const message = JSON.parse(evt.data);
    handleMessage(message);
  };

  websocket.onerror = function(error) {
    console.error('WebSocket error:', error);
  };
}

function handleMessage(message) {
  const event = message.event;
  const context = message.context;
  const payload = message.payload || {};

  switch(event) {
    case 'willAppear':
      onWillAppear(context, payload);
      break;
    case 'willDisappear':
      onWillDisappear(context);
      break;
    case 'keyUp':
      onKeyUp(context, payload);
      break;
    case 'didReceiveSettings':
      onDidReceiveSettings(context, payload);
      break;
  }
}

function onWillAppear(context, payload) {
  const settings = payload.settings || {};
  contexts.set(context, {
    settings: settings,
    currentStatIndex: 0,
    refreshInterval: null,
    cycleInterval: null
  });

  startRefreshInterval(context);
  startCycleInterval(context);
  fetchAndDisplayStats(context);
}

function onWillDisappear(context) {
  const contextData = contexts.get(context);
  if (contextData) {
    if (contextData.refreshInterval) {
      clearInterval(contextData.refreshInterval);
    }
    if (contextData.cycleInterval) {
      clearInterval(contextData.cycleInterval);
    }
  }
  contexts.delete(context);
}

function onKeyUp(context, payload) {
  const contextData = contexts.get(context);
  if (!contextData) return;

  // Cycle to next stat
  const enabledModes = getEnabledModes(contextData.settings);
  contextData.currentStatIndex = (contextData.currentStatIndex + 1) % enabledModes.length;
  displayCurrentStat(context);
}

function onDidReceiveSettings(context, payload) {
  const contextData = contexts.get(context);
  if (contextData) {
    contextData.settings = payload.settings || {};
    fetchAndDisplayStats(context);
  }
}

function startRefreshInterval(context) {
  const contextData = contexts.get(context);
  if (!contextData) return;

  if (contextData.refreshInterval) {
    clearInterval(contextData.refreshInterval);
  }

  contextData.refreshInterval = setInterval(function() {
    fetchAndDisplayStats(context);
  }, REFRESH_INTERVAL);
}

function startCycleInterval(context) {
  const contextData = contexts.get(context);
  if (!contextData) return;

  if (contextData.cycleInterval) {
    clearInterval(contextData.cycleInterval);
  }

  contextData.cycleInterval = setInterval(function() {
    // Only cycle if we have stats loaded
    if (statsCache.has(context)) {
      const enabledModes = getEnabledModes(contextData.settings);
      contextData.currentStatIndex = (contextData.currentStatIndex + 1) % enabledModes.length;
      displayCurrentStat(context);
    }
  }, CYCLE_INTERVAL);
}

function fetchAndDisplayStats(context) {
  const contextData = contexts.get(context);
  if (!contextData) return;

  const settings = contextData.settings;
  const playerName = settings.playerName;
  const platform = settings.platform || 'pc';

  if (!playerName) {
    setImage(context, 'images/logo');
    setTitle(context, '');
    return;
  }

  const url = API_BASE + '?name=' + encodeURIComponent(playerName) + '&platform=' + platform + '&format_values=true';

  fetch(url)
    .then(function(response) {
      if (!response.ok) {
        throw new Error('HTTP ' + response.status);
      }
      return response.json();
    })
    .then(function(data) {
      if (data.errors || !data.userName) {
        setTitle(context, 'Not\nFound');
        return;
      }

      // Get stats from API response
      const kills = data.kills || 0;
      const deaths = data.deaths || 0;
      const wins = data.wins || 0;
      const loses = data.loses || 0;
      const kd = data.killDeath ? data.killDeath.toFixed(2) : '0.00';
      const winPercent = data.winPercent || '0.0%';

      statsCache.set(context, {
        kills: kills,
        deaths: deaths,
        kd: kd,
        wins: wins,
        losses: loses,
        winRate: winPercent.replace('%', ''),
        headshots: data.headShots || 0,
        headshotPercent: data.headshots || '0.0%',
        heals: data.heals || 0,
        repairs: data.repairs || 0,
        revives: data.revives || 0,
        secondsPlayed: data.secondsPlayed || 0,
        assists: data.killAssists || 0,
        matches: data.matchesPlayed || 0,
        playerName: data.userName
      });

      displayCurrentStat(context);
    })
    .catch(function(error) {
      console.error('BF6 Stats fetch error:', error);
      setTitle(context, 'API\nError');
    });
}

function displayCurrentStat(context) {
  const contextData = contexts.get(context);
  const stats = statsCache.get(context);

  if (!contextData || !stats) return;

  const enabledModes = getEnabledModes(contextData.settings);
  const modeIndex = contextData.currentStatIndex % enabledModes.length;
  const mode = enabledModes[modeIndex];
  let title = '';

  switch(mode) {
    case 'logo':
      setImage(context, 'images/logo');
      setTitle(context, '');
      return;
    case 'kd':
      title = 'K/D\n' + stats.kd;
      break;
    case 'kills':
      title = 'Kills\n' + formatNumber(stats.kills);
      break;
    case 'wins':
      title = 'Wins\n' + stats.winRate + '%';
      break;
    case 'headshots':
      title = 'HS\n' + formatNumber(stats.headshots);
      break;
    case 'heals':
      title = 'Heals\n' + formatNumber(stats.heals);
      break;
    case 'repairs':
      title = 'Repairs\n' + formatNumber(stats.repairs);
      break;
    case 'revives':
      title = 'Revives\n' + formatNumber(stats.revives);
      break;
    case 'playtime':
      title = 'Time\n' + formatPlaytime(stats.secondsPlayed);
      break;
    case 'assists':
      title = 'Assists\n' + formatNumber(stats.assists);
      break;
    case 'matches':
      title = 'Matches\n' + formatNumber(stats.matches);
      break;
  }

  clearImage(context);
  setTitle(context, title);
}

function formatNumber(num) {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + 'M';
  } else if (num >= 1000) {
    return (num / 1000).toFixed(1) + 'K';
  }
  return num.toString();
}

function formatPlaytime(seconds) {
  const hours = seconds / 3600;
  if (hours >= 24) {
    const days = hours / 24;
    return days.toFixed(1) + 'd';
  }
  return hours.toFixed(1) + 'h';
}

function setTitle(context, title) {
  if (websocket && websocket.readyState === WebSocket.OPEN) {
    websocket.send(JSON.stringify({
      event: 'setTitle',
      context: context,
      payload: {
        title: title,
        target: 0
      }
    }));
  }
}

function setImage(context, imagePath) {
  if (websocket && websocket.readyState === WebSocket.OPEN) {
    websocket.send(JSON.stringify({
      event: 'setImage',
      context: context,
      payload: {
        image: imagePath,
        target: 0
      }
    }));
  }
}

function clearImage(context) {
  if (websocket && websocket.readyState === WebSocket.OPEN) {
    websocket.send(JSON.stringify({
      event: 'setImage',
      context: context,
      payload: {
        image: null,
        target: 0
      }
    }));
  }
}
</script>
</body>
</html>
